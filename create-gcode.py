#!/usr/bin/env python3
"""
Generates random 3D-printer movement G-code into test.gcode.

Usage (from repo folder):
    python create-gcode.py --min-x 0 --max-x 100 --min-y 0 --max-y 100 --feedrate 50 --count 200
feedrate is given in mm/s (converted to mm/min for G-code).
"""
import argparse
import os
import random
import sys

# Edit yout print_start G-code here
PRINT_START = [
    "; Random movement G-code generated by create-gcode.py",
#    "G28 ; home all axes",
#    "G21 ; set units to mm",
#    "G90 ; absolute positioning",
#    "G92 E0 ; zero extruder (no extrusion used)",
    "print_start",
    "G1 X175 Y175 Z100 F1000"
    ""
]

# Edit your print_end G-code here
PRINT_END = [
    "",
    "; End gcode",
    "G91 ; relative positioning",
    "G1 Z10 F300 ; lift Z",
    "G90 ; absolute positioning",
    "G28 X0 Y0 ; home X Y",
    "M84 ; disable motors",
    "G1 Z100 F300 ; move Z to default height",
    "print_end"
    ""
]

def parse_args():
    p = argparse.ArgumentParser(description="Generate random 3D printer movements (G1) into test.gcode")
    p.add_argument("--min-x", type=float, default=10, help="Minimum X coordinate (default: 10)")
    p.add_argument("--max-x", type=float, required=True, help="Maximum X coordinate")
    p.add_argument("--min-y", type=float, default=10, help="Minimum Y coordinate (default: 10)")
    p.add_argument("--max-y", type=float, required=True, help="Maximum Y coordinate")
    p.add_argument("--min-z", type=float, help="Minimum Z coordinate (optional)")
    p.add_argument("--max-z", type=float, help="Maximum Z coordinate (optional)")
    p.add_argument("--feedrate", type=float, required=True, help="Feedrate in mm/s")
    p.add_argument("--count", type=int, required=True, help="Number of movement commands to generate")
    p.add_argument("-p", "--pause", type=int, metavar="MS", 
                   help="Pause after each movement in milliseconds (optional, e.g. -p 100)")
    return p.parse_args()

def validate_args(a):
    if a.min_x > a.max_x:
        raise ValueError("min-x must be <= max-x")
    if a.min_y > a.max_y:
        raise ValueError("min-y must be <= max-y")
    # Z is optional but both must be provided together
    if (a.min_z is None) != (a.max_z is None):
        raise ValueError("both --min-z and --max-z must be provided together")
    if a.min_z is not None and a.min_z > a.max_z:
        raise ValueError("min-z must be <= max-z")
    if a.feedrate <= 0:
        raise ValueError("feedrate must be > 0")
    if a.count <= 0:
        raise ValueError("count must be > 0")
    if a.pause is not None and a.pause < 0:
        raise ValueError("pause must be >= 0 (milliseconds)")

def generate_moves(min_x, max_x, min_y, max_y, feed_mm_s, count, min_z=None, max_z=None, pause_ms=None):
    feed_mm_min = feed_mm_s * 60.0
    include_z = (min_z is not None and max_z is not None)
    for _ in range(count):
        x = random.uniform(min_x, max_x)
        y = random.uniform(min_y, max_y)
        parts = [f"G1", f"X{x:.3f}", f"Y{y:.3f}"]
        if include_z:
            z = random.uniform(min_z, max_z)
            parts.append(f"Z{z:.3f}")
        parts.append(f"F{feed_mm_min:.0f}")
        yield " ".join(parts)
        if pause_ms is not None:
            # G4 P<ms> pauses for milliseconds on many firmwares
            yield f"G4 P{int(pause_ms)}"

def main():
    args = parse_args()
    try:
        validate_args(args)
    except ValueError as e:
        print("Invalid arguments:", e, file=sys.stderr)
        sys.exit(2)

    out_path = os.path.join(os.path.dirname(__file__), "test.gcode")

    # Use top-level HEADER so users can easily modify it
    print_start = PRINT_START
    print_end = PRINT_END

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(print_start) + "\n")
        for line in generate_moves(args.min_x, args.max_x, args.min_y, args.max_y,
                                   args.feedrate, args.count, args.min_z, args.max_z, args.pause):
            f.write(line + "\n")
        # append end g-code
        f.write("\n".join(print_end) + "\n")

    print(f"Wrote {args.count} movement commands to {out_path}")

if __name__ == "__main__":
    main()